## 1. golang日志框架之logrus

golang标准库的日志框架非常简单，仅仅提供了print，panic和fatal三个函数对于更精细的日志级别、日志文件分割以及日志分发等方面并没有提供支持。所以催生了很多第三方的日志库，但是在golang的世界里，没有一个日志库像slf4j那样在Java中具有绝对统治地位。golang中，流行的日志框架包括logrus、zap、zerolog、seelog等。
logrus是目前Github上star数量最多的日志库，目前(2018.08，下同)star数量为8119，fork数为1031。logrus功能强大，性能高效，而且具有高度灵活性，提供了自定义插件的功能。很多开源项目，如docker，prometheus等，都是用了logrus来记录其日志。
zap是Uber推出的一个快速、结构化的分级日志库。具有强大的ad-hoc分析功能，并且具有灵活的仪表盘。zap目前在GitHub上的star数量约为4.3k。
seelog提供了灵活的异步调度、格式化和过滤功能。目前在GitHub上也有约1.1k。

## 2. 项目地址

https://github.com/sirupsen/logrus

```go
go get -u -v github.com/sirupsen/logrus
```

## 3.logrus特性

logrus具有以下特性：

- 完全兼容golang标准库日志模块：logrus拥有六种日志级别：debug、info、warn、error、fatal和panic，这是golang标准库日志模块的API的超集。如果您的项目使用标准库日志模块，完全可以以最低的代价迁移到logrus上。
- 可扩展的Hook机制：允许使用者通过hook的方式将日志分发到任意地方，如本地文件系统、标准输出、logstash、elasticsearch或者mq等，或者通过hook定义日志内容和格式等。
- 可选的日志输出格式：logrus内置了两种日志格式，`JSONFormatter`和`TextFormatter`，如果这两个格式不满足需求，可以自己动手实现接口`Formatter`，来定义自己的日志格式。
- Field机制：logrus鼓励通过Field机制进行精细化的、结构化的日志记录，而不是通过冗长的消息来记录日志。
- logrus是一个可插拔的、结构化的日志框架。

## 4. 六个日志等级

```go
log.Debug("Useful debugging information.")
log.Info("Something noteworthy happened!")
log.Warn("You should probably take a look at this.")
log.Error("Something failed but I'm not quitting.")
// 随后会触发os.Exit(1)
log.Fatal("Bye.")
// 随后会触发panic()
log.Panic("I'm bailing.")
```

## 5. logrus使用

```go
package main

import (
	log "github.com/sirupsen/logrus"
)

func main() {
	log.WithFields(log.Fields{
		"animal": "walrus",
	}).Info("A walrus appears")
}

// 运行结果 time="2020-10-09T19:05:54+08:00" level=info msg="A walrus appears" animal=walrus
```

```go
package main

import (
	"os"

	"github.com/sirupsen/logrus"
)

func init() {
	// 以JSON格式为输出，代替默认的ASCII格式
	logrus.SetFormatter(&logrus.JSONFormatter{})
	// 以Stdout为输出，代替默认的stderr
	logrus.SetOutput(os.Stdout)
	// 设置日志等级
	logrus.SetLevel(logrus.WarnLevel)
}

func main() {

	logrus.WithFields(logrus.Fields{
		"animal": "walrus",
		"size":   10,
	}).Info("A group of walrus emerges from the ocean")

	logrus.WithFields(logrus.Fields{
		"omg":    true,
		"number": 122,
	}).Warn("The group's number increased tremendously!")

	logrus.WithFields(logrus.Fields{
		"omg":    true,
		"number": 100,
	}).Fatal("The ice breaks!")
}

// 运行结果
// {"level":"warning","msg":"The group's number increased tremendously!","number":122,"omg":true,"time":"2020-10-09T19:16:01+08:00"}
// {"level":"fatal","msg":"The ice breaks!","number":100,"omg":true,"time":"2020-10-09T19:16:01+08:00"}
```

## 6. Logger

如果多个地方使用logging，可以创建一个logrus实例`Logger`

```go
package main

import (
   "os"

   "github.com/sirupsen/logrus"
)

var log = logrus.New()

func main() {
   file, err := os.OpenFile("logrus.log", os.O_CREATE|os.O_WRONLY, 0666)
   if err == nil {
      log.Out = file
   } else {
      log.Info("Failed to log to file, using default stderr")
   }

   log.WithFields(logrus.Fields{
      "animal": "walrus",
      "size":   10,
   }).Info("A group of walrus emerges from the ocean")
   file.Close()
}

// logrus.log文件中的内容
// time="2020-10-10T09:23:21+08:00" level=info msg="A group of walrus emerges from the ocean" animal=walrus size=10
```

## 7. Fields

如果有固定Fields，可以创建一个logrus.Entry

```go
requestLogger := log.WithFields(log.Fields{"request_id": request_id, "user_ip": user_ip})
requestLogger.Info("something happened on that request") # will log request_id and user_ip
requestLogger.Warn("something not great happened")
```

从函数WithFields中可以看出其会返回`*Entry`，Entry中会包含一些变量

```go
// WithFields函数
func WithFields(fields Fields) *Entry {
    return std.WithFields(fields)
}

// Entry结构体
type Entry struct {
    Logger *Logger

    // Contains all the fields set by the user.
    Data Fields

    // Time at which the log entry was created
    Time time.Time

    // Level the log entry was logged at: Debug, Info, Warn, Error, Fatal or Panic
    // This field will be set on entry firing and the value will be equal to the one in Logger struct field.
    Level Level

    // Message passed to Debug, Info, Warn, Error, Fatal or Panic
    Message string

    // When formatter is called in entry.log(), an Buffer may be set to entry
    Buffer *bytes.Buffer
}
```

## 8. Hooks

可以与外面的控件联合，例如

- 使用`github.com/multiplay/go-slack`与`slack`/`bearchat`一些企业团队协作平台/软件联合使用
- 使用`https://github.com/zbindenren/logrus_mail`可以发送email，例如以下实例

### 8.1. go-slack实现bearchat提示

```go
go get -u -v github.com/multiplay/go-slack
```

### 8.2. Hook-Email-logrus_mail.go

```go
go get github.com/zbindenren/logrus_mail
```

