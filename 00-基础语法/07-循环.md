## 1. 概述

前几篇文章分享了 array 数组、slice 切片、map 集合，这篇文章分享如何循环获取里面的元素，同时也是对前几篇文章的复习。

本篇文章会用到的关键字 for、range、break、continue、goto、switch。

## 2. 循环 array

```go
//demo18.go
package main

import (
	"fmt"
)

func main() {
	person := [3] string {"Tom", "Aaron", "John"}
	fmt.Printf("len=%d cap=%d array=%v\n", len(person), cap(person), person)
	
	fmt.Println("")

	//循环
	for k, v := range person {
		fmt.Printf("person[%d]: %s\n", k, v)
	}

	fmt.Println("")

	for i := range person {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	for i := 0; i < len(person); i++ {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	//使用空白符
	for _, name := range person {
		fmt.Println("name :", name)
	}
}
// 运行结果
$ go run 00-基础语法/codes/demo18.go
len=3 cap=3 array=[Tom Aaron John]

person[0]: Tom
person[1]: Aaron
person[2]: John

person[0]: Tom
person[1]: Aaron
person[2]: John

person[0]: Tom
person[1]: Aaron
person[2]: John

name : Tom
name : Aaron
name : John
```



## 3. 循环 slice

```go
//demo19.go
package main

import (
	"fmt"
)

func main() {
	person := [] string {"Tom", "Aaron", "John"}
	fmt.Printf("len=%d cap=%d slice=%v\n", len(person), cap(person), person)

	fmt.Println("")

	//循环
	for k, v := range person {
		fmt.Printf("person[%d]: %s\n", k, v)
	}

	fmt.Println("")

	for i := range person {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	for i := 0; i < len(person); i++ {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	//使用空白符
	for _, name := range person {
		fmt.Println("name :", name)
	}
}

// 运行结果
$ go run 00-基础语法/codes/demo19.go
len=3 cap=3 slice=[Tom Aaron John]

person[0]: Tom
person[1]: Aaron
person[2]: John

person[0]: Tom
person[1]: Aaron
person[2]: John

person[0]: Tom
person[1]: Aaron
person[2]: John

name : Tom
name : Aaron
name : John

```

## 4. 循环 map

```go
//demo20.go
package main

import (
	"fmt"
)

func main() {
	person := map[int]string{
		1 : "Tom",
		2 : "Aaron",
		3 : "John",
	}

	fmt.Printf("len=%d map=%v\n", len(person), person)

	fmt.Println("")

	//循环
	for k, v := range person {
		fmt.Printf("person[%d]: %s\n", k, v)
	}

	fmt.Println("")

	for i := range person {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	for i := 1; i <= len(person); i++ {
		fmt.Printf("person[%d]: %s\n", i, person[i])
	}

	fmt.Println("")

	//使用空白符
	for _, name := range person {
		fmt.Println("name :", name)
	}
}
// 运行结果
$ go run 00-基础语法/codes/demo20.go
len=3 map=map[1:Tom 2:Aaron 3:John]

person[3]: John
person[1]: Tom
person[2]: Aaron

person[3]: John
person[1]: Tom
person[2]: Aaron

person[1]: Tom
person[2]: Aaron
person[3]: John

name : Tom
name : Aaron
name : John
```

## 5. break

跳出当前循环，可⽤于 for、switch、select。

```go
//demo21.go
package main

import "fmt"

func main() {
	for i := 1; i <= 10; i++ {
		if i == 6 {
			break
		}
		fmt.Println("i =", i)
	}
}
// 运行结果
$ go run 00-基础语法/codes/demo21.go
i = 1
i = 2
i = 3
i = 4
i = 5

```

## 6. continue

跳过本次循环，只能用于 for。

```go
//demo22.go
package main

import "fmt"

func main() {
	for i := 1; i <= 10; i++ {
		if i == 6 {
			continue
		}
		fmt.Println("i =", i)
	}
}
// 运行结果
$ go run 00-基础语法/codes/demo22.go
i = 1
i = 2
i = 3
i = 4
i = 5
i = 7
i = 8
i = 9
i = 10
```

## 7. goto

改变函数内代码执行顺序，不能跨函数使用。

```go
//demo23.go
package main

import "fmt"

func main() {
	fmt.Println("begin")

	for i := 1; i <= 10; i++ {
		if i == 6 {
			goto END
		}
		fmt.Println("i =", i)
	}

	END :
		fmt.Println("end")
}
// 运行结果
$ go run 00-基础语法/codes/demo23.go
begin
i = 1
i = 2
i = 3
i = 4
i = 5
end

```

## 8. switch

```
//demo24.go
package main

import "fmt"

func main() {
	i := 1
	fmt.Printf("当 i = %d 时：\n", i)

	switch i {
		case 1:
			fmt.Println("输出 i =", 1)
		case 2:
			fmt.Println("输出 i =", 2)
		case 3:
			fmt.Println("输出 i =", 3)
			fallthrough
		case 4,5,6:
			fmt.Println("输出 i =", "4 or 5 or 6")
		default:
			fmt.Println("输出 i =", "xxx")
	}
}
```

运行结果：

当 i = 1 时：输出 i = 1

当 i = 2 时：输出 i = 2

当 i = 3 时：

输出 i = 3

输出 i = 4 or 5 or 6

当 i = 4 时：输出 i = 4 or 5 or 6

当 i = 7 时：输出 i = xxx

**结论：**

- 默认每个 case 带有 break
- case 中可以有多个选项
- fallthrough 不跳出，并执行下一个 case，一般自己不要写


